//========================================================================
// MinVR
// Platform:    Any
// API version: 1.0
//------------------------------------------------------------------------
// Copyright (c) 2013 Regents of the University of Minnesota
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without modification,
// are permitted provided that the following conditions are met:
//
// * Redistributions of source code must retain the above copyright notice, this
//   list of conditions and the following disclaimer.
//
// * Redistributions in binary form must reproduce the above copyright notice, this
//   list of conditions and the following disclaimer in the documentation and/or
//   other materials provided with the distribution.
//
// * Neither the name of the University of Minnesota, nor the names of its
//   contributors may be used to endorse or promote products derived from
//   this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
// ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
// ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//========================================================================

#ifndef ABSTRACTMVRAPP_H
#define ABSTRACTMVRAPP_H

#include <boost/shared_ptr.hpp>
#include <glm/glm.hpp>
#include "MVRCore/Event.H"
#include "MVRCore/ConfigVal.H"
#include "MVRCore/AbstractCamera.H"
#include "MVRCore/AbstractWindow.H"
#include <vector>

namespace MinVR {

typedef std::shared_ptr<class AbstractMVRApp> AbstractMVRAppRef;

/*! @brief Pure virtual base class for MinVR applications.
 *
 */
class AbstractMVRApp
{
public:

	AbstractMVRApp() {}
	virtual ~AbstractMVRApp() {}

	/*! @brief Handle events and computation
	 * 
	 *  This will be called once per frame.  You should do all your program's logic (handling input events,
	 *  doing any required simulation, and so on) within this function.  If you are doing any simulation or
	 *  animation where virtual objects change over time, it is useful to base this code on the time value
	 *  passed in via the synchronizedTime parameter, which is guaranteed to be synchronized across all
	 *  processes when MinVR is run in a clustered rendering environment.
	 *
	 *  @param[in] An array of events generated by devices, mice, and keyboards
	 *  @param[in] The time that has passed since the application launched in ms.
	 */
	virtual void doUserInputAndPreDrawComputation(const std::vector<EventRef> &events, double synchronizedTime) = 0;

	/*! @brief Initialize OpenGL variables.
	*
	*  This will be called once by each rendering thread as it is created. You should initialize all context
	*  specific variables here such as textures, frame buffer objects, vertex buffer objects, shaders, etc.
	*  Variables can be stored in an array and matched to the specific thread by the threadId, or alternatively,
	*  wrapped as a boost::thread_specific_ptr<> object to automatically create thread specific versions.
	*
	*  @param[in] A unique thread specific id. Ids will start at zero so that they can be used as indices in an array.
	*  @param[in] The window for the calling render thread. Can be used to get the window size, position, etc.
	*
	*  @note Initalizing opengl variables elsewhere in the application is not threadsafe!
	*/
	virtual void initializeContextSpecificVars(int threadId, WindowRef window) = 0;

	/*! @brief Initialize variables after threads are initialized.
	*
	*  This will be called once after initializeContextSpecificVars has been called from each render thread.
	*/
	virtual void postInitialization() = 0;

	/*! @brief Drawing code.
	 *  This is where all your OpenGL drawing code should go.  This routine is typically called more than
	 *  once per frame.  In a desktop VR environment, this would be called once to draw the image for the
	 *  left eye and then a second time to draw the image for the right eye.  In a 4-wall CAVE where the
	 *  a single graphics window is stretched across all the projection screens and divided into 4 different
	 *  OpenGL viewports, one per wall, this routine would be called 8 times per frame (once per eye for 
	 *  each of the walls).  Before calling this routine, MVREngine will appropriately clear the OpenGL draw
	 *  buffer(s), set the OpenGL projection matrices including applying head tracking data if applicable, 
	 *  use the OpenGL viewport command to specify the correct protion of the screen to draw if applicable, 
	 *  and/or set the stencil buffer properly to draw to stereo displays that require a left/right eye 
	 *  interlaced signal if applicable.  MVREngine determines all of those settings based upon the 
	 *  config variables passed to it at runtime that describe your VR environment.  Since all that is
	 *  handled inside MinVR, the only thing that you should implement in this function is the OpenGL
	 *  code needed to draw your scene. 
	 *
	 *  @param[in] A unique id for the current calling renderthread
	 *  @param[in] A reference to the camera, which can be used to set the current object to world transform.
	 *  @param[in] The window for the calling render thread. Can be used to get the window size, position, etc.
	 *
	 *  @note This method is called from multiple render threads. Do not modify variables in this method, as it is not thread-safe.
	 */
	virtual void drawGraphics(int threadId, AbstractCameraRef camera, WindowRef window) = 0;

};



} // end namespace

#endif


